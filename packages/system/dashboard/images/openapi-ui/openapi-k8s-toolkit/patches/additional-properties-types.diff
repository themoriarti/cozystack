diff --git a/src/components/molecules/BlackholeForm/molecules/FormObjectFromSwagger/FormObjectFromSwagger.tsx b/src/components/molecules/BlackholeForm/molecules/FormObjectFromSwagger/FormObjectFromSwagger.tsx
index a7135d4..2fea0bb 100644
--- a/src/components/molecules/BlackholeForm/molecules/FormObjectFromSwagger/FormObjectFromSwagger.tsx
+++ b/src/components/molecules/BlackholeForm/molecules/FormObjectFromSwagger/FormObjectFromSwagger.tsx
@@ -68,13 +68,60 @@ export const FormObjectFromSwagger: FC<TFormObjectFromSwaggerProps> = ({
         properties?: OpenAPIV2.SchemaObject['properties']
         required?: string
       }
+      
+      // Check if the field name exists in additionalProperties.properties
+      // If so, use the type from that property definition
+      const nestedProp = addProps?.properties?.[additionalPropValue] as OpenAPIV2.SchemaObject | undefined
+      let fieldType: string = addProps.type
+      let fieldItems: { type: string } | undefined = addProps.items
+      let fieldNestedProperties = addProps.properties || {}
+      let fieldRequired: string | undefined = addProps.required
+      
+      if (nestedProp) {
+        // Use the nested property definition if it exists
+        // Handle type - it can be string or string[] in OpenAPI v2
+        if (nestedProp.type) {
+          if (Array.isArray(nestedProp.type)) {
+            fieldType = nestedProp.type[0] || addProps.type
+          } else if (typeof nestedProp.type === 'string') {
+            fieldType = nestedProp.type
+          } else {
+            fieldType = addProps.type
+          }
+        } else {
+          fieldType = addProps.type
+        }
+        
+        // Handle items - it can be ItemsObject or ReferenceObject
+        if (nestedProp.items) {
+          // Check if it's a valid ItemsObject with type property
+          if ('type' in nestedProp.items && typeof nestedProp.items.type === 'string') {
+            fieldItems = { type: nestedProp.items.type }
+          } else {
+            fieldItems = addProps.items
+          }
+        } else {
+          fieldItems = addProps.items
+        }
+        
+        fieldNestedProperties = nestedProp.properties || {}
+        // Handle required field - it can be string[] in OpenAPI schema
+        if (Array.isArray(nestedProp.required)) {
+          fieldRequired = nestedProp.required.join(',')
+        } else if (typeof nestedProp.required === 'string') {
+          fieldRequired = nestedProp.required
+        } else {
+          fieldRequired = addProps.required
+        }
+      }
+      
       inputProps?.addField({
         path: Array.isArray(name) ? [...name, String(collapseTitle)] : [name, String(collapseTitle)],
         name: additionalPropValue,
-        type: addProps.type,
-        items: addProps.items,
-        nestedProperties: addProps.properties || {},
-        required: addProps.required,
+        type: fieldType,
+        items: fieldItems,
+        nestedProperties: fieldNestedProperties,
+        required: fieldRequired,
       })
       setAddditionalPropValue(undefined)
     }
diff --git a/src/components/molecules/BlackholeForm/molecules/FormStringInput/FormStringInput.tsx b/src/components/molecules/BlackholeForm/molecules/FormStringInput/FormStringInput.tsx
index 487d480..3ca46c1 100644
--- a/src/components/molecules/BlackholeForm/molecules/FormStringInput/FormStringInput.tsx
+++ b/src/components/molecules/BlackholeForm/molecules/FormStringInput/FormStringInput.tsx
@@ -42,7 +42,11 @@ export const FormStringInput: FC<TFormStringInputProps> = ({
   const formValue = Form.useWatch(formFieldName)
 
   // Derive multiline based on current local value
-  const isMultiline = useMemo(() => isMultilineString(formValue), [formValue])
+  const isMultiline = useMemo(() => {
+    // Normalize value for multiline check
+    const value = typeof formValue === 'string' ? formValue : (formValue === null || formValue === undefined ? '' : String(formValue))
+    return isMultilineString(value)
+  }, [formValue])
 
   const title = (
     <>
@@ -77,6 +81,23 @@ export const FormStringInput: FC<TFormStringInputProps> = ({
         rules={[{ required: forceNonRequired === false && required?.includes(getStringByName(name)) }]}
         validateTrigger="onBlur"
         hasFeedback={designNewLayout ? { icons: feedbackIcons } : true}
+        normalize={(value) => {
+          // Normalize value to string - prevent "[object Object]" display
+          if (value === undefined || value === null) {
+            return ''
+          }
+          if (typeof value === 'string') {
+            return value
+          }
+          if (typeof value === 'number' || typeof value === 'boolean') {
+            return String(value)
+          }
+          // If it's an object or array, it shouldn't be in a string field - return empty string
+          if (typeof value === 'object') {
+            return ''
+          }
+          return String(value)
+        }}
       >
         <Input.TextArea
           placeholder={getStringByName(name)}
diff --git a/src/components/molecules/BlackholeForm/organisms/BlackholeForm/helpers/casts.ts b/src/components/molecules/BlackholeForm/organisms/BlackholeForm/helpers/casts.ts
index 6f9eb39..835224c 100644
--- a/src/components/molecules/BlackholeForm/organisms/BlackholeForm/helpers/casts.ts
+++ b/src/components/molecules/BlackholeForm/organisms/BlackholeForm/helpers/casts.ts
@@ -124,8 +124,26 @@ export const materializeAdditionalFromValues = (
    *
    * This is used when a new field appears in the data but doesn't yet exist in the schema.
    */
-  const makeChildFromAP = (ap: any): OpenAPIV2.SchemaObject => {
-    const t = ap?.type ?? 'object'
+  const makeChildFromAP = (ap: any, value?: unknown): OpenAPIV2.SchemaObject => {
+    // Determine type based on actual value if not explicitly defined in additionalProperties
+    let t = ap?.type
+    if (!t && value !== undefined && value !== null) {
+      if (Array.isArray(value)) {
+        t = 'array'
+      } else if (typeof value === 'object') {
+        t = 'object'
+      } else if (typeof value === 'string') {
+        t = 'string'
+      } else if (typeof value === 'number') {
+        t = 'number'
+      } else if (typeof value === 'boolean') {
+        t = 'boolean'
+      } else {
+        t = 'object'
+      }
+    }
+    t = t ?? 'object'
+    
     const child: OpenAPIV2.SchemaObject = { type: t } as any
 
     // Copy common schema details (if present)
@@ -134,6 +152,20 @@ export const materializeAdditionalFromValues = (
     if (ap?.required)
       (child as any).required = _.cloneDeep(ap.required)
 
+    // If value is an array and items type is not defined, infer it from the first item
+    if (t === 'array' && Array.isArray(value) && value.length > 0 && !ap?.items) {
+      const firstItem = value[0]
+      if (typeof firstItem === 'string') {
+        ;(child as any).items = { type: 'string' }
+      } else if (typeof firstItem === 'number') {
+        ;(child as any).items = { type: 'number' }
+      } else if (typeof firstItem === 'boolean') {
+        ;(child as any).items = { type: 'boolean' }
+      } else if (typeof firstItem === 'object') {
+        ;(child as any).items = { type: 'object' }
+      }
+    }
+
       // Mark as originating from `additionalProperties`
     ;(child as any).isAdditionalProperties = true
     return child
@@ -177,7 +209,16 @@ export const materializeAdditionalFromValues = (
 
           // If the key doesn't exist in schema, create it from `additionalProperties`
           if (!schemaNode.properties![k]) {
-            schemaNode.properties![k] = makeChildFromAP(ap)
+            // Check if there's a nested property definition in additionalProperties
+            const nestedProp = ap?.properties?.[k]
+            if (nestedProp) {
+              // Use the nested property definition from additionalProperties
+              schemaNode.properties![k] = _.cloneDeep(nestedProp) as any
+              ;(schemaNode.properties![k] as any).isAdditionalProperties = true
+            } else {
+              // Create from additionalProperties with value-based type inference
+              schemaNode.properties![k] = makeChildFromAP(ap, vo[k])
+            }
             // If it's an existing additional property, merge any nested structure
           } else if ((schemaNode.properties![k] as any).isAdditionalProperties && ap?.properties) {
             ;(schemaNode.properties![k] as any).properties ??= _.cloneDeep(ap.properties)
diff --git a/src/components/molecules/BlackholeForm/organisms/BlackholeForm/utils.tsx b/src/components/molecules/BlackholeForm/organisms/BlackholeForm/utils.tsx
index 2d887c7..d69d711 100644
--- a/src/components/molecules/BlackholeForm/organisms/BlackholeForm/utils.tsx
+++ b/src/components/molecules/BlackholeForm/organisms/BlackholeForm/utils.tsx
@@ -394,9 +394,11 @@ export const getArrayFormItemFromSwagger = ({
           {(fields, { add, remove }, { errors }) => (
             <>
               {fields.map(field => {
-                const fieldType = (
+                const rawFieldType = (
                   schema.items as (OpenAPIV2.ItemsObject & { properties?: OpenAPIV2.SchemaObject }) | undefined
                 )?.type
+                // Handle type as string or string[] (OpenAPI v2 allows both)
+                const fieldType = Array.isArray(rawFieldType) ? rawFieldType[0] : rawFieldType
                 const description = (schema.items as (OpenAPIV2.ItemsObject & { description?: string }) | undefined)
                   ?.description
                 const entry = schema.items as
@@ -577,7 +579,29 @@ export const getArrayFormItemFromSwagger = ({
                   type="text"
                   size="small"
                   onClick={() => {
-                    add()
+                    // Determine initial value based on item type
+                    const fieldType = (
+                      schema.items as (OpenAPIV2.ItemsObject & { properties?: OpenAPIV2.SchemaObject }) | undefined
+                    )?.type
+                    
+                    let initialValue: unknown
+                    // Handle type as string or string[] (OpenAPI v2 allows both)
+                    const typeStr = Array.isArray(fieldType) ? fieldType[0] : fieldType
+                    if (typeStr === 'string') {
+                      initialValue = ''
+                    } else if (typeStr === 'number' || typeStr === 'integer') {
+                      initialValue = 0
+                    } else if (typeStr === 'boolean') {
+                      initialValue = false
+                    } else if (typeStr === 'array') {
+                      initialValue = []
+                    } else if (typeStr === 'object') {
+                      initialValue = {}
+                    } else {
+                      initialValue = ''
+                    }
+                    
+                    add(initialValue)
                   }}
                 >
                   <PlusIcon />

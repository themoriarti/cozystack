diff --git a/pkg/ovn_leader_checker/ovn.go b/pkg/ovn_leader_checker/ovn.go
index 0f86a371d..8ddf7bca6 100755
--- a/pkg/ovn_leader_checker/ovn.go
+++ b/pkg/ovn_leader_checker/ovn.go
@@ -10,6 +10,7 @@ import (
 	"os/exec"
 	"strconv"
 	"strings"
+	"sync"
 	"syscall"
 	"time"
 
@@ -271,19 +272,56 @@ func checkNorthdSvcExist(cfg *Configuration, namespace, svcName string) bool {
 	return true
 }
 
-func checkNorthdEpAvailable(ip string) bool {
-	address := net.JoinHostPort(ip, OvnNorthdPort)
-	conn, err := net.DialTimeout("tcp", address, 3*time.Second)
-	if err != nil {
-		klog.Errorf("failed to connect to northd leader %s, err: %v", ip, err)
-		failCount++
-		if failCount >= MaxFailCount {
-			return false
-		}
-	} else {
+func checkNorthdEpAvailable(ips ...string) bool {
+	var wg sync.WaitGroup
+	success := make(chan struct{}, 1)
+	failure := make(chan struct{})
+	ctx, cancel := context.WithCancel(context.Background())
+	defer cancel()
+	d := net.Dialer{Timeout: 3 * time.Second}
+	for _, ip := range ips {
+		address := net.JoinHostPort(ip, OvnNorthdPort)
+		wg.Add(1)
+		go func() {
+			defer wg.Done()
+			conn, err := d.DialContext(ctx, "tcp", address)
+			if err != nil {
+				klog.Errorf("failed to connect to northd leader %s, err: %v", ip, err)
+				return
+			} else {
+				defer conn.Close()
+				select {
+				case success <- struct{}{}:
+					klog.V(5).Infof("succeed to connect to northd leader %s", ip)
+					cancel()
+				default:
+					// someone else already succeeded
+				}
+			}
+		}()
+	}
+	go func() {
+		wg.Wait()
+		close(failure)
+	}()
+	select {
+	case <-success:
 		failCount = 0
-		klog.V(5).Infof("succeed to connect to northd leader %s", ip)
-		_ = conn.Close()
+		return true
+	case <-failure:
+		// if the last groroutine is the one to succeed,
+		// there's a small chance that failure is selected,
+		// this is a guard for this
+		select {
+		case <-success:
+			failCount = 0
+			return true
+		default:
+			failCount++
+			if failCount >= MaxFailCount {
+				return false
+			}
+		}
 	}
 	return true
 }
@@ -295,6 +333,8 @@ func checkNorthdEpAlive(cfg *Configuration, namespace, service string) bool {
 		return false
 	}
 
+	addresses := []string{}
+
 	for _, eps := range epsList.Items {
 		for _, ep := range eps.Endpoints {
 			if (ep.Conditions.Ready != nil && !*ep.Conditions.Ready) || len(ep.Addresses) == 0 {
@@ -303,12 +343,15 @@ func checkNorthdEpAlive(cfg *Configuration, namespace, service string) bool {
 
 			// Found an address, check its availability. We only need one.
 			klog.V(5).Infof("found address %s in endpoint slice %s/%s for service %s, checking availability", ep.Addresses[0], eps.Namespace, eps.Name, service)
-			return checkNorthdEpAvailable(ep.Addresses[0])
+			addresses = append(addresses, ep.Addresses[0]) // Addresses are fungible by k8s API design
 		}
 	}
 
-	klog.V(5).Infof("no address found in any endpoint slices for service %s/%s", namespace, service)
-	return false
+	if len(addresses) == 0 {
+		klog.V(5).Infof("no address found in any endpoint slices for service %s/%s", namespace, service)
+		return false
+	}
+	return checkNorthdEpAvailable(addresses...)
 }
 
 func compactOvnDatabase(db string) {
